import { app, HttpRequest, HttpResponseInit, InvocationContext } from "@azure/functions";
import PDFDocument from "pdfkit";

type OrderItem = {
    id: number;
    product_id: number;
    name_snapshot: string;
    unit_price_snapshot: number;
    qty: number;
};

type OrderResponse = {
    data: {
        id: number;
        user_id: number;
        status: "pending_payment" | "paid" | "failed";
        total_price: number;
        items: OrderItem[];
        created_at?: string;
    };
};

function euros(cents: number) {
    return (cents / 100).toFixed(2);
}

function requireEnv(name: string): string {
    const v = process.env[name];
    if (!v) throw new Error(`Missing env: ${name}`);
    return v;
}

async function fetchOrder(orderId: number, bearer: string): Promise<OrderResponse> {
    const base = requireEnv("ORDER_SERVICE_BASE_URL").replace(/\/$/, "");
    const url = `${base}/items/${orderId}`;

    const res = await fetch(url, {
        headers: {
            Accept: "application/json",
            Authorization: bearer,
        },
    });

    if (res.status === 401) throw new Error("Unauthorized");
    if (res.status === 404) throw new Error("NotFound");
    if (!res.ok) throw new Error(`Order service error: ${res.status}`);

    return (await res.json()) as OrderResponse;
}

function pdfToBuffer(build: (doc: PDFDocument) => void): Promise<Buffer> {
    return new Promise((resolve, reject) => {
        const doc = new PDFDocument({ size: "A4", margin: 50 });
        const chunks: Buffer[] = [];

        doc.on("data", (c) => chunks.push(Buffer.isBuffer(c) ? c : Buffer.from(c)));
        doc.on("end", () => resolve(Buffer.concat(chunks)));
        doc.on("error", reject);

        build(doc);
        doc.end();
    });
}

function buildInvoicePdf(order: OrderResponse["data"]): Promise<Buffer> {
    const companyName = process.env["INVOICE_COMPANY_NAME"] ?? "CloudShopt";
    const companyLine = process.env["INVOICE_COMPANY_LINE"] ?? "Timch Ecomm sandbox";
    const currency = "EUR";

    return pdfToBuffer((doc) => {
        // Header
        doc.fontSize(18).text(companyName, { align: "left" });
        doc.fontSize(10).text(companyLine);
        doc.moveDown(1);

        // Invoice meta
        doc.fontSize(14).text(`Invoice #${order.id}`);
        doc.fontSize(10).text(`Date: ${new Date().toISOString().slice(0, 10)}`);
        doc.fontSize(10).text(`Order status: ${order.status}`);
        doc.moveDown(1);

        // Table header
        doc.fontSize(11).text("Item", 50, doc.y, { continued: true });
        doc.text("Qty", 320, doc.y, { width: 50, align: "right", continued: true });
        doc.text("Unit", 390, doc.y, { width: 70, align: "right", continued: true });
        doc.text("Total", 470, doc.y, { width: 70, align: "right" });
        doc.moveDown(0.5);
        doc.moveTo(50, doc.y).lineTo(545, doc.y).stroke();
        doc.moveDown(0.5);

        // Rows
        order.items.forEach((it) => {
            const lineTotal = it.unit_price_snapshot * it.qty;

            doc.fontSize(10).text(it.name_snapshot, 50, doc.y, { width: 260, continued: true });
            doc.text(String(it.qty), 320, doc.y, { width: 50, align: "right", continued: true });
            doc.text(`${euros(it.unit_price_snapshot)} ${currency}`, 390, doc.y, { width: 70, align: "right", continued: true });
            doc.text(`${euros(lineTotal)} ${currency}`, 470, doc.y, { width: 70, align: "right" });
        });

        doc.moveDown(1);
        doc.moveTo(50, doc.y).lineTo(545, doc.y).stroke();
        doc.moveDown(0.5);

        // Total
        doc.fontSize(12).text(`Total: ${euros(order.total_price)} ${currency}`, 50, doc.y, { align: "right" });

        doc.moveDown(2);
        doc.fontSize(9).text("Generated by CloudShopt Invoice Function (Azure Functions).", { align: "left" });
    });
}

app.http("invoice", {
    methods: ["GET"],
    authLevel: "anonymous",
    route: "invoice",
    handler: async (req: HttpRequest, context: InvocationContext): Promise<HttpResponseInit> => {
        try {
            const orderIdRaw = req.query.get("order_id");
            const orderId = orderIdRaw ? Number(orderIdRaw) : NaN;
            if (!orderIdRaw || Number.isNaN(orderId) || orderId < 1) {
                return { status: 400, jsonBody: { message: "Missing/invalid order_id" } };
            }

            const auth = req.headers.get("authorization") ?? "";
            if (!auth.toLowerCase().startsWith("bearer ")) {
                return { status: 401, jsonBody: { message: "Missing Bearer token" } };
            }

            const orderRes = await fetchOrder(orderId, auth);
            const order = orderRes.data;

            if (order.status !== "paid") {
                return { status: 409, jsonBody: { message: "Invoice is available only for paid orders." } };
            }

            const pdf = await buildInvoicePdf(order);

            return {
                status: 200,
                body: new Uint8Array(pdf),
                headers: {
                    "Content-Type": "application/pdf",
                    "Content-Disposition": `attachment; filename="invoice-${order.id}.pdf"`,
                    "Cache-Control": "no-store",
                },
            };
        } catch (e: any) {
            context.error(e);

            const msg = String(e?.message ?? e);
            if (msg === "Unauthorized") return { status: 401, jsonBody: { message: "Unauthorized" } };
            if (msg === "NotFound") return { status: 404, jsonBody: { message: "Order not found" } };

            return { status: 500, jsonBody: { message: "Failed to generate invoice" } };
        }
    },
});